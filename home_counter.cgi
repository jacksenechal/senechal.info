#!/usr/bin/perl
# $Id: counter,v 1.1 1994/04/18 14:48:00 root Exp $
#
# counter - increment a counter for WWW
#
# neat things left to do:
#	- create a new file if it does not exist
#	- maintain "backup" of #'s in case of spontaneous reset
#
#
# 6/12/95 - *finally* gotten around to making this accepct an argument
#	    as the counter file to increment
#		m.l.nelson@larc.nasa.gov
#
# 5/11/94 - removed inetd dependency; now uses cgi-bin Michael Nelson 
#		m.l.nelson@larc.nasa.gov
#
# Written 3/8/94 by Dan Rich (drich@corp.sgi.com)
#     Based on C code written by Frans van Hoesel (hoesel@chem.rug.nl)
#
# $Log: counter,v $
# Revision 1.1  1994/04/18  14:48:00  root
# Initial revision
#
#

sub usage {
    print STDERR "usage: $0 [-i]\n";
    exit 1;
}

if ( $ENV{QUERY_STRING} eq "" )
{
	$counterfile = "home_hits.txt";
}
else
{
	$counterfile = "/temp/" . $ENV{QUERY_STRING};
}


require('getopts.pl') || die "can\'t do getopts.pl: $@";
#require('sys/file.ph') || die "can\'t do sys/file.ph: $@";

if ( ! &Getopts('i') ) {
    &usage();
}
$opt_i = 1; # change to 0 for non inverse
$inv = $opt_i;

# bitmap for each digit
@invdigits = (0xff,0xff,0xff,0xc3,0x99,0x99,0x99,0x99,
           0x99,0x99,0x99,0x99,0xc3,0xff,0xff,0xff,
           0xff,0xff,0xff,0xcf,0xc7,0xcf,0xcf,0xcf,
           0xcf,0xcf,0xcf,0xcf,0xcf,0xff,0xff,0xff,
           0xff,0xff,0xff,0xc3,0x99,0x9f,0x9f,0xcf,
           0xe7,0xf3,0xf9,0xf9,0x81,0xff,0xff,0xff,
           0xff,0xff,0xff,0xc3,0x99,0x9f,0x9f,0xc7,
           0x9f,0x9f,0x9f,0x99,0xc3,0xff,0xff,0xff,
           0xff,0xff,0xff,0xcf,0xcf,0xc7,0xc7,0xcb,
           0xcb,0xcd,0x81,0xcf,0x87,0xff,0xff,0xff,
           0xff,0xff,0xff,0x81,0xf9,0xf9,0xf9,0xc1,
           0x9f,0x9f,0x9f,0x99,0xc3,0xff,0xff,0xff,
           0xff,0xff,0xff,0xc7,0xf3,0xf9,0xf9,0xc1,
           0x99,0x99,0x99,0x99,0xc3,0xff,0xff,0xff,
           0xff,0xff,0xff,0x81,0x99,0x9f,0x9f,0xcf,
           0xcf,0xe7,0xe7,0xf3,0xf3,0xff,0xff,0xff,
           0xff,0xff,0xff,0xc3,0x99,0x99,0x99,0xc3,
           0x99,0x99,0x99,0x99,0xc3,0xff,0xff,0xff,
           0xff,0xff,0xff,0xc3,0x99,0x99,0x99,0x99,
           0x83,0x9f,0x9f,0xcf,0xe3,0xff,0xff,0xff
           );
@digits = (0x00,0x00,0x00,0x3c,0x66,0x66,0x66,0x66,
           0x66,0x66,0x66,0x66,0x3c,0x00,0x00,0x00,
           0x00,0x00,0x00,0x30,0x38,0x30,0x30,0x30,
           0x30,0x30,0x30,0x30,0x30,0x00,0x00,0x00,
           0x00,0x00,0x00,0x3c,0x66,0x60,0x60,0x30,
           0x18,0x0c,0x06,0x06,0x7e,0x00,0x00,0x00,
           0x00,0x00,0x00,0x3c,0x66,0x60,0x60,0x38,
           0x60,0x60,0x60,0x66,0x3c,0x00,0x00,0x00,
           0x00,0x00,0x00,0x30,0x30,0x38,0x38,0x34,
           0x34,0x32,0x7e,0x30,0x78,0x00,0x00,0x00,
           0x00,0x00,0x00,0x7e,0x06,0x06,0x06,0x3e,
           0x60,0x60,0x60,0x66,0x3c,0x00,0x00,0x00,
           0x00,0x00,0x00,0x38,0x0c,0x06,0x06,0x3e,
           0x66,0x66,0x66,0x66,0x3c,0x00,0x00,0x00,
           0x00,0x00,0x00,0x7e,0x66,0x60,0x60,0x30,
           0x30,0x18,0x18,0x0c,0x0c,0x00,0x00,0x00,
           0x00,0x00,0x00,0x3c,0x66,0x66,0x66,0x3c,
           0x66,0x66,0x66,0x66,0x3c,0x00,0x00,0x00,
           0x00,0x00,0x00,0x3c,0x66,0x66,0x66,0x66,
           0x7c,0x60,0x60,0x30,0x1c,0x00,0x00,0x00
           );

$hex = "0123456789abcdef";

# Read and increment the counter file
while (-f "${counterfile}.lock") { sleep 1;}
open(LOCK,">${counterfile}.lock");
open(COUNTERFILE,"<$counterfile") || die "can\'t open $counterfile: $!\n";
#flock(COUNTERFILE,&LOCK_EX) || die "can\'t lock $counterfile: $!\n";
$text = <COUNTERFILE>;
close(COUNTERFILE);
$text++;
$len = length($text) > 7 ? length($text) : 7;
open(COUNTERFILE,">$counterfile") || die "can\'t open $counterfile: $!\n";
printf COUNTERFILE "%0${len}u\n",$text;
$text = sprintf("%0${len}u",$text);
#flock(COUNTERFILE,&LOCK_UN);
close(COUNTERFILE);
unlink("${counterfile}.lock");

# Generate an X11 bitmap on STDOUT
print &PrintHeader; #mln
printf STDOUT "#define count_width %d\n#define count_height 16\n", $len*8;
printf STDOUT "static char count_bits[] = {\n";
for ($y=0; $y < 16; $y++) {
    for ($x=0; $x < $len; $x++) {
        $d = substr($text,$x,1) - '0';
        print STDOUT '0x';
        if ($inv) {             # $inv = 1 for inverted text
            printf STDOUT "%1x",($invdigits[($d * 16) + $y] >> 4) & 0xf;
            printf STDOUT "%1x",$invdigits[($d * 16) + $y] & 0xf;
        } else {
            printf STDOUT "%1x",($digits[($d * 16) + $y] >> 4) & 0xf;
            printf STDOUT "%1x",$digits[($d * 16) + $y] & 0xf;
        }
        if ($x < $len-1) {
            print STDOUT ',';
        }
    }
    if ($y==15) {
        print STDOUT '};';
    } else {
        print STDOUT ',';
    }
    print STDOUT "\n";
}

# PrintHeader
# Returns the magic line which tells WWW that we're an HTML document

sub PrintHeader {
  return "Content-type: image/x-xbitmap\n\n";
}

